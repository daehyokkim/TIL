# REST API 설계 해보기

> 백엔드 개발자과 프론트엔드 개발자 간의 협업에서 빠질 수 없는 API명세서에  대해 기초와 방법들을 알아보자!!



### REST API란?

>  REST 아키텍처의 제약 조건을 준수한 애플리케이션 프로그래밍 인터페이스를 의미함

HTTP URI를 통해 자원을 명시하고, Methode를 통해 자원에 대한 CRUD 옵션을 적용한다.

#### API 는 무엇?

- ~~FM 으로 말하면~~  애플리케이션 소프트웨어를 구축하고 통합하기 위한 정의 및 프로토콜 세트로, 애플리케이션 프로그래밍 인터페이스를 나타냅니다.

- ~~**한마디로**~~ API는  프로그램들이 서로 상호작용할 수 있도록 도와주는 **매개체**로 생각하자:punch:

- API의  역할은:dizzy:

  1. 서버와 DB에 대한 출입구 역할

     DB에는 중요한 정보들이 저장된 공간인데 모든 유저가 이를 접근 한다면?? **엄청나 위험**을 불려 일을 킬 수 다. 이를 **방지**하기위해 유저가 가진 서버와DB에 대한 출입구 역할을 하며 **허용된 사람만** 접근성을 부여 해줌:ok_man:

  2. 애플리케이션과 기기가 원할하게 통신할 수 있도록 한다

     API는 애플리케이션과 기기가 데이터를 원할히 주고받을 수 있도록 돕는 역할을 해줌

  3. 모든 접속을 **포준화**

     API는 모든 접속을 표준화하기 때무에 기기/OS 등과 상관없이 누구나 **동일한** **[엑세스](https://m.blog.naver.com/PostView.nhn?blogId=sheepgh8186&logNo=221650661797&proxyReferer=https:%2F%2Fwww.google.com%2F)** 얻을 수 있어:ok:



#### REST의 장단점

- 장점
  - HTTP 프로토콜의 인프라를 그대로 사용하여 별도의 인프라를 구축할 필요가 없어
  - HTTP 플로토콜에 따른 모든 플랫폼에서 사용할 수 있다:+1:
  - REST API 메시지가 의도하는 바를 명확히 나타내 의도를 쉽게 파악 가능함
  - 서버와 클라이언트의 역할을 명확히 분리가 가능
- 단점
  - **표준이** **존재하지** **않음** :slightly_frowning_face:

#### 필요한 이유

- **애플리케이션 분리 및 통합**
- **당야한 클라이언트의 등자**

- **멀티 플랫폼에 대한 지원을 위해 서비스 자원에 대한 아키텍스가 필수가 됨**



#### REST 구성요소

1. 자원(Resource): URI
   - 모든 자원에 고유한 ID가 존재하며, 이 자원은 **서버**에 존재한다.
   - 자원을 구별하는 ID는 ‘/groups/:group_id’와 같은 HTTP URI:o:
   - Client는 URI를 이용해서 자원을 지정하고 해당 자원의 상태(정보)에 대한 조작을 Server에 요청한다.:star:

2. 행위(Verb): HTTP Method
   - HTTP 프로토콜의 Method를 사용한다.
   - HTTP 프로토콜은 GET, POST, PUT, DELETE 와 같은 메서드를 제공한다.
3. 표현(Representation of Resource)
   - Client가 자원의 상태(정보)에 대한 조작을 요청하면 Server는 이에 적절한 응답(Representation)을 보낸다.
   - REST에서 하나의 자원은 **JSON**, **XML**, **TEXT**, **RSS** 등 여러 형태의 Representation으로 나타내어 질 수 있다.
   - JSON 혹은 XML를 통해 데이터를 주고 받는 것이 일반적이다.



#### REST의 특징 

1. **Uniform** **Interface**(일관된 인터페이스)
   - URI로 지정한 Resource에 대한 조작을 통일됙 한정적인 인터페이스로 수행
   - HTTP 표준 프로토콜에 따르는 모든 플랫폼에서 사용 가능 **특정 언어에 종속:x:**
2. **Stateless**(무상태성)
   - Client의 context를 Server에 저장하지 않음
     - 세션과 쿠키와 같은 context 정보를 신경쓰지 않아도 되므로 구현이 단순해진다.
   - Server는 각각의 요청을 완전히 별개의 것으로 인식하고 처리
     - 각 API 서버는 Client의 요청만을 단순 처리한다.
     - 이전 요청이 DB를 수정해 바뀌는 것 외의 이전 요청은 다음 요청에 연관되서는 안된다.
     - Server의 처리 방식에 일관성을 부여하고 부담이 줄어들며, 서비스의 자유도가 높아진다.
3. **Cacheable**(캐시 가능)
   - 웹에서 사용하는 기존의 인프라를 그대로 활용할 수 있음.
     - 즉, HTTP가 가진 가장 강력한 특징 중 하나인 **캐싱 기능**을 적용할 수 있다.
   - 대량의 요청을 효율적으로 처리하기 위해 캐시가 요구된다.
   - 캐시 사용을 통해 응답시간이 빨라지고:fast_forward: REST Server 트랜잭션이 발생하지 않기 때문에 전체 **응답시간**, **성능**, **서버의** **자원** **이용률**을 향상시킬 수 있다. :scream:
   - [캐시가 무엇???](https://ko.wikipedia.org/wiki/%EC%BA%90%EC%8B%9C)

4. **Client-Server Architecture**(서버-클라이언트 구조)
   - Server :man_cook:
     - 자원:cocktail: 이 있음
     - API를 제공하고 비즈니스 로직 처리 및 저장을 책임
   - Client:man:
     - 자원:cocktail:을 요청하는 쪽
     - 시용자 인증,context 등을 직접 관리,책임짐
   - **서로 간 의존성이 줄어줌**
5. **Self-Descriptiveness**(자체 표현)
   - **메세지만 보고 명확**해야 된다. :star2:
   - **목적지가 명확**해야 된다.:star2:
6. **Layered System**(계층 구조)
   - Client는 REST API Server만 호출
   - REST Server는 다중 계층으로 구성될 수 있다.
     - API Server는 순수 비즈니스 로직을 수행하고 그 앞단에 보안, 로드밸런싱, 암호화, 사용자 인증 등을 추가하여 구조상의 유연성을 줄 수 있다.
     - 또한 로드밸런싱, 공유 캐시 등을 통해 확장성과 보안성을 향상시킬 수 있다.
   - PROXY, 게이트웨이 같은 네트워크 기반의 중간 매체를 사용할 수 있다.